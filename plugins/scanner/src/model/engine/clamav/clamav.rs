/* automatically generated by rust-bindgen 0.66.1 */

#![allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]

pub const CL_DB_DIRECTORY: u32 = 2048;
pub const CL_SCAN_GENERAL_YARAHIT: u32 = 32;
pub const CL_SCAN_PARSE_ARCHIVE: u32 = 1;
pub const CL_SCAN_PARSE_ELF: u32 = 2;
pub const CL_SCAN_PARSE_PE: u32 = 512;
pub const CL_INIT_DEFAULT: u32 = 0;
pub type __time_t = ::std::os::raw::c_long;
pub type __suseconds_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub const cl_error_t_CL_CLEAN: cl_error_t = 0;
pub const cl_error_t_CL_SUCCESS: cl_error_t = 0;
pub const cl_error_t_CL_VIRUS: cl_error_t = 1;
pub const cl_error_t_CL_ENULLARG: cl_error_t = 2;
pub const cl_error_t_CL_EARG: cl_error_t = 3;
pub const cl_error_t_CL_EMALFDB: cl_error_t = 4;
pub const cl_error_t_CL_ECVD: cl_error_t = 5;
pub const cl_error_t_CL_EVERIFY: cl_error_t = 6;
pub const cl_error_t_CL_EUNPACK: cl_error_t = 7;
pub const cl_error_t_CL_EOPEN: cl_error_t = 8;
pub const cl_error_t_CL_ECREAT: cl_error_t = 9;
pub const cl_error_t_CL_EUNLINK: cl_error_t = 10;
pub const cl_error_t_CL_ESTAT: cl_error_t = 11;
pub const cl_error_t_CL_EREAD: cl_error_t = 12;
pub const cl_error_t_CL_ESEEK: cl_error_t = 13;
pub const cl_error_t_CL_EWRITE: cl_error_t = 14;
pub const cl_error_t_CL_EDUP: cl_error_t = 15;
pub const cl_error_t_CL_EACCES: cl_error_t = 16;
pub const cl_error_t_CL_ETMPFILE: cl_error_t = 17;
pub const cl_error_t_CL_ETMPDIR: cl_error_t = 18;
pub const cl_error_t_CL_EMAP: cl_error_t = 19;
pub const cl_error_t_CL_EMEM: cl_error_t = 20;
pub const cl_error_t_CL_ETIMEOUT: cl_error_t = 21;
pub const cl_error_t_CL_BREAK: cl_error_t = 22;
pub const cl_error_t_CL_EMAXREC: cl_error_t = 23;
pub const cl_error_t_CL_EMAXSIZE: cl_error_t = 24;
pub const cl_error_t_CL_EMAXFILES: cl_error_t = 25;
pub const cl_error_t_CL_EFORMAT: cl_error_t = 26;
pub const cl_error_t_CL_EPARSE: cl_error_t = 27;
pub const cl_error_t_CL_EBYTECODE: cl_error_t = 28;
pub const cl_error_t_CL_EBYTECODE_TESTFAIL: cl_error_t = 29;
pub const cl_error_t_CL_ELOCK: cl_error_t = 30;
pub const cl_error_t_CL_EBUSY: cl_error_t = 31;
pub const cl_error_t_CL_ESTATE: cl_error_t = 32;
pub const cl_error_t_CL_VERIFIED: cl_error_t = 33;
pub const cl_error_t_CL_ERROR: cl_error_t = 34;
pub const cl_error_t_CL_ELAST_ERROR: cl_error_t = 35;
pub type cl_error_t = ::std::os::raw::c_uint;
#[doc = " scan options"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cl_scan_options {
    pub general: u32,
    pub parse: u32,
    pub heuristic: u32,
    pub mail: u32,
    pub dev: u32,
}
#[test]
fn bindgen_test_layout_cl_scan_options() {
    const UNINIT: ::std::mem::MaybeUninit<cl_scan_options> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cl_scan_options>(),
        20usize,
        concat!("Size of: ", stringify!(cl_scan_options))
    );
    assert_eq!(
        ::std::mem::align_of::<cl_scan_options>(),
        4usize,
        concat!("Alignment of ", stringify!(cl_scan_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).general) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_scan_options),
            "::",
            stringify!(general)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parse) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_scan_options),
            "::",
            stringify!(parse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).heuristic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_scan_options),
            "::",
            stringify!(heuristic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mail) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_scan_options),
            "::",
            stringify!(mail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dev) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_scan_options),
            "::",
            stringify!(dev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cl_engine {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Initialize the ClamAV library.\n\n @param initoptions   Unused.\n @return cl_error_t   CL_SUCCESS if everything initalized correctly."]
    pub fn cl_init(initoptions: ::std::os::raw::c_uint) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Allocate a new scanning engine and initialize default settings.\n\n The engine should be freed with `cl_engine_free()`.\n\n @return struct cl_engine* Pointer to the scanning engine."]
    pub fn cl_engine_new() -> *mut cl_engine;
}
pub const cl_engine_field_CL_ENGINE_MAX_SCANSIZE: cl_engine_field = 0;
pub const cl_engine_field_CL_ENGINE_MAX_FILESIZE: cl_engine_field = 1;
pub const cl_engine_field_CL_ENGINE_MAX_RECURSION: cl_engine_field = 2;
pub const cl_engine_field_CL_ENGINE_MAX_FILES: cl_engine_field = 3;
pub const cl_engine_field_CL_ENGINE_MIN_CC_COUNT: cl_engine_field = 4;
pub const cl_engine_field_CL_ENGINE_MIN_SSN_COUNT: cl_engine_field = 5;
pub const cl_engine_field_CL_ENGINE_PUA_CATEGORIES: cl_engine_field = 6;
pub const cl_engine_field_CL_ENGINE_DB_OPTIONS: cl_engine_field = 7;
pub const cl_engine_field_CL_ENGINE_DB_VERSION: cl_engine_field = 8;
pub const cl_engine_field_CL_ENGINE_DB_TIME: cl_engine_field = 9;
pub const cl_engine_field_CL_ENGINE_AC_ONLY: cl_engine_field = 10;
pub const cl_engine_field_CL_ENGINE_AC_MINDEPTH: cl_engine_field = 11;
pub const cl_engine_field_CL_ENGINE_AC_MAXDEPTH: cl_engine_field = 12;
pub const cl_engine_field_CL_ENGINE_TMPDIR: cl_engine_field = 13;
pub const cl_engine_field_CL_ENGINE_KEEPTMP: cl_engine_field = 14;
pub const cl_engine_field_CL_ENGINE_BYTECODE_SECURITY: cl_engine_field = 15;
pub const cl_engine_field_CL_ENGINE_BYTECODE_TIMEOUT: cl_engine_field = 16;
pub const cl_engine_field_CL_ENGINE_BYTECODE_MODE: cl_engine_field = 17;
pub const cl_engine_field_CL_ENGINE_MAX_EMBEDDEDPE: cl_engine_field = 18;
pub const cl_engine_field_CL_ENGINE_MAX_HTMLNORMALIZE: cl_engine_field = 19;
pub const cl_engine_field_CL_ENGINE_MAX_HTMLNOTAGS: cl_engine_field = 20;
pub const cl_engine_field_CL_ENGINE_MAX_SCRIPTNORMALIZE: cl_engine_field = 21;
pub const cl_engine_field_CL_ENGINE_MAX_ZIPTYPERCG: cl_engine_field = 22;
pub const cl_engine_field_CL_ENGINE_FORCETODISK: cl_engine_field = 23;
pub const cl_engine_field_CL_ENGINE_DISABLE_CACHE: cl_engine_field = 24;
pub const cl_engine_field_CL_ENGINE_DISABLE_PE_STATS: cl_engine_field = 25;
pub const cl_engine_field_CL_ENGINE_STATS_TIMEOUT: cl_engine_field = 26;
pub const cl_engine_field_CL_ENGINE_MAX_PARTITIONS: cl_engine_field = 27;
pub const cl_engine_field_CL_ENGINE_MAX_ICONSPE: cl_engine_field = 28;
pub const cl_engine_field_CL_ENGINE_MAX_RECHWP3: cl_engine_field = 29;
pub const cl_engine_field_CL_ENGINE_MAX_SCANTIME: cl_engine_field = 30;
pub const cl_engine_field_CL_ENGINE_PCRE_MATCH_LIMIT: cl_engine_field = 31;
pub const cl_engine_field_CL_ENGINE_PCRE_RECMATCH_LIMIT: cl_engine_field = 32;
pub const cl_engine_field_CL_ENGINE_PCRE_MAX_FILESIZE: cl_engine_field = 33;
pub const cl_engine_field_CL_ENGINE_DISABLE_PE_CERTS: cl_engine_field = 34;
pub const cl_engine_field_CL_ENGINE_PE_DUMPCERTS: cl_engine_field = 35;
pub type cl_engine_field = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct yr_hit_cb_ctx {
    pub hits: *mut *mut ::std::os::raw::c_char,
    pub hit_cnt: u32,
}
#[test]
fn bindgen_test_layout_yr_hit_cb_ctx() {
    const UNINIT: ::std::mem::MaybeUninit<yr_hit_cb_ctx> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<yr_hit_cb_ctx>(),
        16usize,
        concat!("Size of: ", stringify!(yr_hit_cb_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<yr_hit_cb_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(yr_hit_cb_ctx))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(yr_hit_cb_ctx),
            "::",
            stringify!(hits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hit_cnt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(yr_hit_cb_ctx),
            "::",
            stringify!(hit_cnt)
        )
    );
}
pub type yr_hit_ctx = yr_hit_cb_ctx;
extern "C" {
    #[doc = " @brief Free a yara hit data pointer.\n\n @param ctx      The hit data struct pointer.\n @return cl_error_t   CL_SUCCESS if successful.\n @return cl_error_t   CL_ENULLARG null arguments were provided."]
    pub fn cl_yr_hit_cb_ctx_free(ctx: *mut yr_hit_ctx) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Init a yara hit data pointer.\n\n @return ctx   The hit data struct pointer."]
    pub fn cl_yr_hit_cb_ctx_init() -> *mut yr_hit_ctx;
}
extern "C" {
    #[doc = " @brief Set a numerical engine option.\n\n Caution: changing options for an engine that is in-use is not thread-safe!\n\n @param engine            An initialized scan engine.\n @param cl_engine_field   A CL_ENGINE option.\n @param num               The new engine option value.\n @return cl_error_t       CL_SUCCESS if successfully set.\n @return cl_error_t       CL_EARG if the field number was incorrect.\n @return cl_error_t       CL_ENULLARG null arguments were provided."]
    pub fn cl_engine_set_num(
        engine: *mut cl_engine,
        field: cl_engine_field,
        num: ::std::os::raw::c_longlong,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Prepare the scanning engine.\n\n Called this after all required databases have been loaded and settings have\n been applied.\n\n @param engine        A scan engine.\n @return cl_error_t   CL_SUCCESS if successful.\n @return cl_error_t   CL_ENULLARG null arguments were provided."]
    pub fn cl_engine_compile(engine: *mut cl_engine) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Add a reference count to the engine.\n\n Thread safety mechanism so that the engine is not free'd by another thread.\n\n The engine is initialized with refcount = 1, so this only needs to be called\n for additional scanning threads.\n\n @param engine        A scan engine.\n @return cl_error_t   CL_SUCCESS if successful.\n @return cl_error_t   CL_ENULLARG null arguments were provided."]
    pub fn cl_engine_addref(engine: *mut cl_engine) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Free an engine.\n\n Will lower the reference count on an engine. If the reference count hits\n zero, the engine will be freed.\n\n @param engine        A scan engine.\n @return cl_error_t   CL_SUCCESS if successful.\n @return cl_error_t   CL_ENULLARG null arguments were provided."]
    pub fn cl_engine_free(engine: *mut cl_engine) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Scan a file, given a filename.\n\n @param filename          Filepath of the file to be scanned.\n @param[out] virname      Will be set to a statically allocated (i.e. needs not be freed) signature name if the scan matches against a signature.\n @param[out] scanned      The number of bytes scanned.\n @param engine            The scanning engine.\n @param scanoptions       Scanning options.\n @return cl_error_t       CL_CLEAN, CL_VIRUS, or an error code if an error occured during the scan."]
    pub fn cl_scanfile(
        filename: *const ::std::os::raw::c_char,
        virname: *mut *const ::std::os::raw::c_char,
        scanned: *mut ::std::os::raw::c_ulong,
        engine: *const cl_engine,
        scanoptions: *mut cl_scan_options,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Scan a file, given a filename.\n\n This callback variant allows the caller to provide a context structure that caller provided callback functions can interpret.\n\n @param filename          Filepath of the file to be scanned.\n @param[out] virname      Will be set to a statically allocated (i.e. needs not be freed) signature name if the scan matches against a signature.\n @param[out] scanned      The number of bytes scanned.\n @param engine            The scanning engine.\n @param scanoptions       Scanning options.\n @param[in,out] context   An opaque context structure allowing the caller to record details about the sample being scanned.\n @return cl_error_t       CL_CLEAN, CL_VIRUS, or an error code if an error occured during the scan."]
    pub fn cl_scanfile_callback(
        filename: *const ::std::os::raw::c_char,
        virname: *mut *const ::std::os::raw::c_char,
        scanned: *mut ::std::os::raw::c_ulong,
        engine: *const cl_engine,
        scanoptions: *mut cl_scan_options,
        context: *mut ::std::os::raw::c_void,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Load the signature databases found at the path.\n\n @param path          May be a file or directory.\n @param engine        The engine to load the signatures into\n @param[out] signo    The number of signatures loaded\n @param dboptions     Database load bitflag field. See the CL_DB_* defines, above.\n @return cl_error_t"]
    pub fn cl_load(
        path: *const ::std::os::raw::c_char,
        engine: *mut cl_engine,
        signo: *mut ::std::os::raw::c_uint,
        dboptions: ::std::os::raw::c_uint,
    ) -> cl_error_t;
}
extern "C" {
    pub fn cl_strerror(clerror: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cl_fmap {
    _unused: [u8; 0],
}
pub type cl_fmap_t = cl_fmap;
extern "C" {
    #[doc = " @brief Open a map given a buffer.\n\n Open a map for scanning custom data, where the data is already in memory,\n either in the form of a buffer, a memory mapped file, etc.\n Note that the memory [start, start+len) must be the _entire_ file,\n you can't give it parts of a file and expect detection to work.\n\n @param start         Pointer to a buffer of data.\n @param len           Length in bytes of the data.\n @return cl_fmap_t*   A map representing the buffer."]
    pub fn cl_fmap_open_memory(start: *const ::std::os::raw::c_void, len: usize) -> *mut cl_fmap_t;
}
extern "C" {
    #[doc = " @brief Releases resources associated with the map.\n\n You should release any resources you hold only after (handles, maps) calling\n this function.\n\n @param map           Map to be closed."]
    pub fn cl_fmap_close(arg1: *mut cl_fmap_t);
}
extern "C" {
    #[doc = " @brief Scan custom data.\n\n @param map           Buffer to be scanned, in form of a cl_fmap_t.\n @param filename      Name of data origin. Does not need to be an actual\n                      file on disk. May be NULL if a name is not available.\n @param[out] virname  Pointer to receive the signature match name name if a\n                      signature matched.\n @param[out] scanned  Number of bytes scanned.\n @param engine        The scanning engine.\n @param scanoptions   The scanning options struct.\n @param context       An application-defined context struct, opaque to\n                      libclamav. May be used within your callback functions.\n @return cl_error_t   CL_CLEAN if no signature matched. CL_VIRUS if a\n                      signature matched. Another CL_E* error code if an\n                      error occured."]
    pub fn cl_scanmap_callback(
        map: *mut cl_fmap_t,
        filename: *const ::std::os::raw::c_char,
        virname: *mut *const ::std::os::raw::c_char,
        scanned: *mut ::std::os::raw::c_ulong,
        engine: *const cl_engine,
        scanoptions: *mut cl_scan_options,
        context: *mut ::std::os::raw::c_void,
    ) -> cl_error_t;
}
